#!/usr/bin/env bash
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# temporal:link <service_name> <app_name> [--namespace=<name>]
temporal:link() {
    local service_name="$1"
    local app_name="$2"
    local namespace="default"
    shift 2
    debug_log "[temporal:link] Called for service '$service_name', app '$app_name'."

    # Parse optional --namespace flag
    while [[ $# -gt 0 ]]; do
        case $1 in
            --namespace=*)
                namespace="${1#*=}"
                shift
                ;;
            --namespace)
                namespace="$2"
                shift 2
                ;;
            *)
                echo "Error: Unknown option: $1"
                return 1
                ;;
        esac
    done

    if ! validate_service_name "$service_name" "link"; then return 1; fi
    if [ -z "$app_name" ]; then
        echo "Usage: dokku $PLUGIN_COMMAND_PREFIX:link <service_name> <app_name> [--namespace=<name>]"
        return 1
    fi

    # Check if Temporal service exists
    if ! service_exists "$service_name"; then
        echo "Error: Temporal service '$service_name' does not exist."
        return 1
    fi

    local db_type
    db_type=$(service_info_get "$service_name" "DB_TYPE")
    if [ -z "$db_type" ]; then
        echo "Error: Temporal service '$service_name' is missing DB_TYPE configuration."
        return 1
    fi

    # Check if app exists
    if ! dokku apps:exists "$app_name" >/dev/null 2>&1; then # Assuming apps:exists is quiet or redirecting
        echo "Error: Dokku app '$app_name' does not exist."
        return 1
    fi

    # Validate namespace exists if not default
    if [[ "$namespace" != "default" ]]; then
        if ! namespace_exists "$service_name" "$namespace"; then
            echo "Error: Namespace '$namespace' does not exist for service '$service_name'."
            echo "Available namespaces:"
            namespace_list_all "$service_name" | sed 's/^/  - /'
            echo ""
            echo "Create it with: dokku $PLUGIN_COMMAND_PREFIX:namespace:create $service_name $namespace"
            return 1
        fi
    fi

    echo "Linking Temporal service '$service_name' (type: $db_type) to app '$app_name' with namespace '$namespace'..."

    # Get connection info for the underlying datastore
    # This uses the get_db_connection_info from common.sh
    local connection_info
    connection_info=$(get_db_connection_info "$service_name")
    if [ $? -ne 0 ] || [ -z "$connection_info" ]; then
        echo "Error: Could not retrieve database connection info for '$service_name'."
        return 1
    fi
    debug_log "[temporal:link] Retrieved connection info: $connection_info"

    # Set environment variables on the app
    # Example TEMPORAL_HOST might be the Dokku host or a service-specific address
    # For now, let's assume direct connection to Temporal server on default gRPC port
    # This needs more thought based on how 'temporal:start' exposes the service.
    # If 'temporal:start' uses Docker port mapping, TEMPORAL_GRPC_ADDRESS would be something like dokku-host-ip:port
    # For now, placeholders. Crucially, the DB link for Temporal server itself is internal.
    # The app needs to know how to reach the Temporal Frontend Service.
    # This example assumes temporal server runs on the host mapped to 7233.
    # A better way: `dokku temporal:urls <service_name>` to get client-usable URLs.

    # Standard Dokku practice is to link the *datastore* to the app,
    # then the app uses that to connect to Temporal, which then connects to the datastore.
    # Or, if Temporal server is also a "service" for the app:

    # Use the Docker container name for internal networking
    # This allows the app container to reach Temporal via Docker's DNS
    local container_name="temporal-server-$service_name"
    local temporal_address="$container_name:7233"

    # Ensure the Temporal server container exists and is running
    if ! docker ps --filter "name=^${container_name}$" --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Warning: Temporal server container '$container_name' is not running."
        echo "Please start it with: dokku $PLUGIN_COMMAND_PREFIX:start $service_name"
    fi

    # Use the temporal-network that was created during temporal:create
    local temporal_network="temporal-network"

    # Verify the network exists
    if ! docker network inspect "$temporal_network" >/dev/null 2>&1; then
        echo "Error: Network '$temporal_network' does not exist!"
        echo "Please create the service first with: dokku $PLUGIN_COMMAND_PREFIX:create $service_name"
        return 1
    fi

    # Use Dokku's native network management to attach app to temporal-network
    # attach-post-create ensures network is connected before app starts
    echo "Configuring app to use temporal-network..."
    dokku network:set "$app_name" attach-post-create "$temporal_network"

    echo "Setting environment variables on app '$app_name'..."
    dokku config:set --no-restart "$app_name" \
        "TEMPORAL_ADDRESS=$temporal_address" \
        "TEMPORAL_NAMESPACE=$namespace"

    # Link the underlying datastore (e.g., postgres) to the app if Temporal SDKs need it directly
    # OR if the app itself is a Temporal worker/client that configures its own DB connection
    # This depends on the use case. Often, apps only talk to Temporal frontend, not its DB.
    # For now, let's assume app only needs TEMPORAL_ADDRESS.
    # If the actual *Temporal server components* were running as part of an "app",
    # then you'd use 'dokku postgres:link $service_name $temporal_server_app_name'.

    # Add to your plugin's global list of linked apps
    add_linked_app "$service_name" "$app_name"

    echo "Successfully linked Temporal service '$service_name' to app '$app_name'."
    echo "App '$app_name' may need to be restarted to pick up new environment variables."
    return 0
}