#!/usr/bin/env bash
# Source config first to ensure PLUGIN_DATA_ROOT is set
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../config"

set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Common functions used across commands

# Debug logging helper - respects DOKKU_TRACE
# Must be defined early so it can be used below
debug_log() {
    if [[ -n "$DOKKU_TRACE" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

# PLUGIN_DATA_ROOT should be set in config file (sourced above)
# If for some reason it's not set, fall back to default
if [[ -z "${PLUGIN_DATA_ROOT}" ]]; then
    export PLUGIN_DATA_ROOT="${DOKKU_LIB_ROOT:-/var/lib/dokku}/services/temporal"
fi
debug_log "[./functions/common] PLUGIN_DATA_ROOT set to: $PLUGIN_DATA_ROOT"
debug_log "[./functions/common] Sourced."

# Get the service directory path
service_root() {
    local service_name="$1"
    echo "$PLUGIN_DATA_ROOT/$service_name"
}

# Check if a service exists (has a directory)
service_exists() {
    local service_name="$1"
    local service_dir
    service_dir=$(service_root "$service_name")
    [[ -d "$service_dir" ]]
}

# Set a service info value (stores in a file)
service_info_set() {
    local service_name="$1"
    local key="$2"
    local value="$3"
    local service_dir
    service_dir=$(service_root "$service_name")

    debug_log "[service_info_set] PLUGIN_DATA_ROOT=$PLUGIN_DATA_ROOT"
    debug_log "[service_info_set] Creating directory: $service_dir"
    
    # Ensure parent directory exists with correct permissions
    if [[ ! -d "$PLUGIN_DATA_ROOT" ]]; then
        mkdir -p "$PLUGIN_DATA_ROOT"
        # Try to set ownership to dokku:dokku if possible (may fail if dokku user doesn't exist, that's ok)
        chown dokku:dokku "$PLUGIN_DATA_ROOT" 2>/dev/null || true
        chmod 755 "$PLUGIN_DATA_ROOT"
    fi
    
    mkdir -p "$service_dir" || {
        echo "Error: Failed to create service directory: $service_dir" >&2
        return 1
    }
    # Set ownership to dokku:dokku so the dokku user can read it (may fail if dokku user doesn't exist, that's ok)
    chown dokku:dokku "$service_dir" 2>/dev/null || true
    chmod 755 "$service_dir"
    debug_log "[service_info_set] Writing $key=$value to $service_dir/$key"
    echo "$value" > "$service_dir/$key" || {
        echo "Error: Failed to write to $service_dir/$key" >&2
        return 1
    }
    # Set ownership on the file as well (may fail if dokku user doesn't exist, that's ok)
    chown dokku:dokku "$service_dir/$key" 2>/dev/null || true
    chmod 644 "$service_dir/$key"
    debug_log "[service_info_set] Successfully stored $key for service $service_name in $service_dir/$key"
}

# Get a service info value (reads from a file)
service_info_get() {
    local service_name="$1"
    local key="$2"
    local service_dir
    service_dir=$(service_root "$service_name")

    if [[ -f "$service_dir/$key" ]]; then
        cat "$service_dir/$key"
    fi
}

# List all services (directories in PLUGIN_DATA_ROOT)
service_list_all() {
    debug_log "[service_list_all] PLUGIN_DATA_ROOT=$PLUGIN_DATA_ROOT"
    if [[ ! -d "$PLUGIN_DATA_ROOT" ]]; then
        debug_log "[service_list_all] Directory does not exist: $PLUGIN_DATA_ROOT"
        return 0
    fi

    # Check if we can read the directory
    if [[ ! -r "$PLUGIN_DATA_ROOT" ]]; then
        debug_log "[service_list_all] Cannot read directory: $PLUGIN_DATA_ROOT (permission denied)"
        return 0
    fi

    debug_log "[service_list_all] Searching for services in: $PLUGIN_DATA_ROOT"
    local services
    
    # Use a subshell to change to the target directory before listing
    # This avoids permission issues with the current working directory (e.g., /root)
    services=$(cd "$PLUGIN_DATA_ROOT" 2>/dev/null && ls -1 -d */ 2>/dev/null | sed 's|/$||' | sort)
    
    # If that fails (e.g., can't cd), try find from a safe directory
    if [[ -z "$services" ]]; then
        debug_log "[service_list_all] ls approach failed, trying find from /tmp"
        local old_pwd
        old_pwd=$(pwd 2>/dev/null || echo "/tmp")
        cd /tmp 2>/dev/null || true
        services=$(find "$PLUGIN_DATA_ROOT" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; 2>/dev/null | sort)
        cd "$old_pwd" 2>/dev/null || true
    fi
    
    debug_log "[service_list_all] Found services: $services"
    echo "$services"
}

# Check if a database plugin exists by checking its 'commands' script
check_db_plugin() {
    local db_type="$1"
    debug_log "[check_db_plugin] Checking for existence and executability of '$db_type' plugin's command script."

    # PLUGIN_ENABLED_PATH is exported by Dokku's environment, e.g., /var/lib/dokku/plugins/enabled
    local target_plugin_commands_script="$PLUGIN_ENABLED_PATH/$db_type/commands"

    debug_log "[check_db_plugin] Target script path: $target_plugin_commands_script"

    if [ -f "$target_plugin_commands_script" ] && [ -x "$target_plugin_commands_script" ]; then
        debug_log "[check_db_plugin] Command script for '$db_type' plugin found and is executable."
        debug_log "[check_db_plugin] Assuming plugin '$db_type' is installed and enabled."
        return 0
    else
        if [ ! -f "$target_plugin_commands_script" ]; then
            debug_log "[check_db_plugin] Command script for '$db_type' NOT FOUND at $target_plugin_commands_script."
        elif [ ! -x "$target_plugin_commands_script" ]; then
            debug_log "[check_db_plugin] Command script for '$db_type' FOUND but NOT EXECUTABLE at $target_plugin_commands_script."
        fi
        # User-facing error message
        echo "Error: $db_type plugin is not installed or not correctly enabled (commands script missing or not executable)."
        return 1
    fi
}

# Get database connection info (reads from filesystem)
get_db_connection_info() {
    local service_name="$1"
    local db_type
    db_type=$(service_info_get "$service_name" "DB_TYPE")
    debug_log "[get_db_connection_info] For service '$service_name', db_type from filesystem: '$db_type'"

    if [ -z "$db_type" ]; then
        echo "Warning: [get_db_connection_info] DB_TYPE not found for '$service_name'. Cannot reliably get DB info." >&2
        return 1 # Cannot proceed without knowing db_type
    fi

    # Check if a custom database service name is configured
    local actual_db_service
    actual_db_service=$(service_info_get "$service_name" "DB_SERVICE_NAME")
    if [ -n "$actual_db_service" ]; then
        debug_log "[get_db_connection_info] Using custom database service name: '$actual_db_service'"
    else
        actual_db_service="$service_name"
        debug_log "[get_db_connection_info] Using default database service name: '$actual_db_service'"
    fi

    debug_log "[get_db_connection_info] Using db_type '$db_type' to fetch Dokku db info for '$actual_db_service'"
    local db_info
    db_info=$(dokku "$db_type":info "$actual_db_service" --dsn 2>/dev/null || dokku "$db_type":info "$actual_db_service" --quiet 2>/dev/null)
    local db_info_rc=$?

    if [ $db_info_rc -ne 0 ] || [ -z "$db_info" ]; then
        echo "Error: Could not get DB info for '$actual_db_service' using type '$db_type'. 'dokku $db_type:info $actual_db_service' failed or returned empty." >&2
        return 1
    fi
    debug_log "[get_db_connection_info] Raw db_info/DSN: $db_info"

    local db_scheme db_user db_password db_host db_port db_name
    if [[ "$db_info" =~ ([^:]+)://([^:]*):([^@]*)@([^:]+):([0-9]+)/([^?]+) ]]; then # Made user/pass parsing more robust for empty values
        db_scheme="${BASH_REMATCH[1]}"
        db_user="${BASH_REMATCH[2]}"
        db_password="${BASH_REMATCH[3]}"
        db_host="${BASH_REMATCH[4]}"
        db_port="${BASH_REMATCH[5]}"
        db_name="${BASH_REMATCH[6]}"
    else
        echo "Warning: [get_db_connection_info] Could not parse DSN '$db_info' for '$service_name'. Manual parsing or different format needed." >&2
        db_host="PARSE_ERROR_HOST"
        db_port="PARSE_ERROR_PORT"
        db_name="PARSE_ERROR_DBNAME"
        db_user="PARSE_ERROR_USER"
        db_password="PARSE_ERROR_PASS"
    fi

    echo "DB_HOST=$db_host"
    echo "DB_PORT=$db_port"
    echo "DB_NAME=$db_name"
    echo "DB_USER=$db_user"
    echo "DB_PASSWORD=$db_password"
}

# Sanitize service name for use in environment variable names
# Converts hyphens to underscores since env var names can't contain hyphens
sanitize_service_name_for_env() {
    local service_name="$1"
    echo "${service_name//-/_}"
}

# Validate service name
validate_service_name() {
    local service_name="$1"
    local cmd="$2"
    debug_log "[validate_service_name] Called for service_name='$service_name', cmd='$cmd'"
    if [ -z "$service_name" ]; then
        echo "Usage: dokku $PLUGIN_COMMAND_PREFIX:$cmd <service_name>"
        return 1
    fi
    # Add regex check for valid service name characters (e.g., alphanumeric, dash)
    if [[ ! "$service_name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]*$ ]]; then
        echo "Error: Invalid service name '$service_name'. Name must start with alphanumeric and contain only alphanumeric, underscore, or hyphen."
        return 1
    fi
    debug_log "[validate_service_name] Service name '$service_name' provided and format is valid."
    return 0
}

# No longer needed - service existence is determined by directory existence

# Add app to linked apps list (stored in filesystem)
add_linked_app() {
    local service_name="$1"
    local app_name="$2"
    debug_log "[add_linked_app] Linking service '$service_name' to app '$app_name'"

    local service_dir
    service_dir=$(service_root "$service_name")
    local links_file="$service_dir/LINKS"

    # Create service directory if it doesn't exist
    mkdir -p "$service_dir"
    # Set ownership to dokku:dokku so the dokku user can read it (may fail if dokku user doesn't exist, that's ok)
    chown dokku:dokku "$service_dir" 2>/dev/null || true
    chmod 755 "$service_dir"

    # Add app to links file if not already present
    if [[ -f "$links_file" ]] && grep -q "^${app_name}$" "$links_file"; then
        debug_log "[add_linked_app] App '$app_name' already linked to service '$service_name'"
    else
        echo "$app_name" >> "$links_file"
        # Set ownership on the file (may fail if dokku user doesn't exist, that's ok)
        chown dokku:dokku "$links_file" 2>/dev/null || true
        chmod 644 "$links_file"
        debug_log "[add_linked_app] Added app '$app_name' to links file"
    fi
}

# Remove app from linked apps list
remove_linked_app() {
    local service_name="$1"
    local app_name="$2"
    debug_log "[remove_linked_app] Unlinking app '$app_name' from service '$service_name'"

    local service_dir
    service_dir=$(service_root "$service_name")
    local links_file="$service_dir/LINKS"

    if [[ ! -f "$links_file" ]]; then
        debug_log "[remove_linked_app] No links file found"
        return
    fi

    # Remove the app from the links file
    local temp_file="${links_file}.tmp"
    grep -v "^${app_name}$" "$links_file" > "$temp_file" 2>/dev/null || true
    mv "$temp_file" "$links_file"

    # Remove links file if empty
    if [[ ! -s "$links_file" ]]; then
        rm -f "$links_file"
        debug_log "[remove_linked_app] Removed empty links file"
    fi
}

# Get linked apps for a service
get_linked_apps() {
    local service_name="$1"
    debug_log "[get_linked_apps] Getting apps linked to '$service_name'"

    local service_dir
    service_dir=$(service_root "$service_name")
    local links_file="$service_dir/LINKS"

    if [[ -f "$links_file" ]]; then
        cat "$links_file"
    fi
}